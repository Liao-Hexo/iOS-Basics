## SonarQube介绍

SonarQube是一个开源的代码质量扫描分析工具，分为`Community`、`Developer`、`Enterprise`、`Data Center`四个版本，其中`Community`社区版免费开源，针对很多语言都可以扫描，但是针对iOS，社区版不支持`Objective-C`、`Swift`扫描，只有开发版及以上收费版本才支持。因此我们需要用开源插件`sonar-swift`以实现在`SonarQube`上iOS的代码质量扫描分析。

## 安装java 11

其它的java版本不被SonarQube官方支持，前往java官网，下载java 11：`https://www.oracle.com/java/technologies/downloads/#java11-mac`

```shell
java --version

java 11.0.17 2022-10-18 LTS
Java(TM) SE Runtime Environment 18.9 (build 11.0.17+10-LTS-269)
Java HotSpot(TM) 64-Bit Server VM 18.9 (build 11.0.17+10-LTS-269, mixed mode)
```

## 安装SonarQube

注意：不要下载最新的SonarQube版本，因为sonar-swift-jar包并不支持，因此建议使用官方提供的长期支持和维护的版本`SonarQube 8.9.7 LTS`。

下载地址：`https://www.sonarqube.org/downloads/`

```shell
cd /Users/liaojialong/Downloads/sonar-swift扫描/sonarqube-8.9.7.52159/bin/macosx-universal-64
sh ./sonar.sh start
```

启动成功后，登录默认网址：`http://localhost:9000`，初始账号密码都是`admin`,首次登录系统会要求修改密码。

## 下载sonar-swift插件

下载地址：`https://github.com/Idean/sonar-swift/releases/tag/0.4.6`

下载后的插件放到该目录下：`/Users/liaojialong/Downloads/sonar-swift扫描/sonarqube-8.9.7.52159/extensions/plugins/backelite-sonar-swift-plugin-0.4.6.jar`

并重启SonarQube：`sh ./sonar.sh restart`

## 安装sonar-scanner

```shell
brew install sonar-scanner
sonar-scanner --version

INFO: Scanner configuration file: /opt/homebrew/Cellar/sonar-scanner/4.7.0.2747/libexec/conf/sonar-scanner.properties
INFO: Project root configuration file: NONE
INFO: SonarScanner 4.7.0.2747
INFO: Java 11.0.16.1 Homebrew (64-bit)
INFO: Mac OS X 12.5.1 aarch64
```

## 安装swiftlint

```shell
brew install swiftlint
swiftlint --version

0.49.1
```

## 配置sonar-project.properties文件

在要扫描的项目根目录下新建一个名为`sonar-project.properties`的文件，文件内容如下：

```shell
#
# Swift SonarQube Plugin - Enables analysis of Swift and Objective-C projects into SonarQube.
# Copyright © 2015 Backelite (${email})
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU Lesser General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU Lesser General Public License for more details.
#
# You should have received a copy of the GNU Lesser General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#

sonar.projectKey=Daily-BillprjKey
sonar.projectName=Daily-Bill
# Number version (can be found automatically in plist, just comment this line)
sonar.projectVersion=1.0

# Comment if you have a project with mixed ObjC / Swift
sonar.language=swift

# Project description
sonar.projectDescription=prjDescription

# Path to source directories
sonar.sources=.
# Path to test directories (comment if no test)
# sonar.tests=TestDir

# Destination Simulator to run surefire
# As string expected in destination argument of xcodebuild command
# Example = sonar.swift.simulator=platform=iOS Simulator,name=iPhone 6,OS=9.2
sonar.swift.simulator=platform=iOS Simulator,name=iPhone 14,OS=16.0

# Xcode project configuration (.xcodeproj)
# and use the later to specify which project(s) to include in the analysis (comma separated list)
# Specify either xcodeproj or xcodeproj + xcworkspace
sonar.swift.project=Daily-Bill.xcodeproj
sonar.swift.workspace=Daily-Bill.xcworkspace

# Scheme to build your application
sonar.swift.appScheme=Daily-Bill

sonar.login=admin
sonar.password=ljl20000328

# Specify your appname when different from targeted scheme.
# Or when slather fails with 'No product binary found'
# You can also provide a list of framework names to analyse for coverage.
# This will be something like "myApp" or "myApp,myFramework"
# sonar.coverage.binaryNames=myApp,myFramework

# Configuration to use for your scheme. if you do not specify that the default will be Debug
sonar.swift.appConfiguration=MyConfiguration

##########################
# Optional configuration #
##########################
# Encoding of the source code
sonar.sourceEncoding=UTF-8
# SCM
# sonar.scm.enabled=true
# sonar.scm.url=scm:git:http://xxx

# JUnit report generated by run-sonar.sh is stored in sonar-reports/TEST-report.xml
# Change it only if you generate the file on your own
# The XML files have to be prefixed by TEST- otherwise they are not processed
# sonar.junit.reportsPath=sonar-reports/

# Lizard report generated by run-sonar.sh is stored in sonar-reports/lizard-report.xml
# Change it only if you generate the file on your own
# sonar.swift.lizard.report=sonar-reports/lizard-report.xml

# Cobertura report generated by run-sonar.sh is stored in sonar-reports/coverage-swift.xml
# Change it only if you generate the file on your own
# sonar.swift.coverage.reportPattern=sonar-reports/coverage-swift*.xml

# OCLint report generated by run-sonar.sh is stored in sonar-reports/oclint.xml
# Change it only if you generate the file on your own
 sonar.swift.swiftlint.report=sonar-reports/*swiftlint.txt

# Change it only if you generate the file on your own
# sonar.swift.tailor.report=sonar-reports/*tailor.txt

# Paths to exclude from coverage report (surefire, 3rd party libraries etc.)
# sonar.swift.excludedPathsFromCoverage=pattern1,pattern2
sonar.swift.excludedPathsFromCoverage=.*Tests.*

# Ability to skip tests (such as UI Tests running long time)
# Example = sonar.swift.skipTests=UITests

##########################
# Tailor configuration #
##########################
# Tailor configuration
# -l,--max-line-length=<0-999>                  maximum Line length (in characters)
#    --list-files                               display Swift source files to be analyzed
#    --max-class-length=<0-999>                 maximum Class length (in lines)
#    --max-closure-length=<0-999>               maximum Closure length (in lines)
#    --max-file-length=<0-999>                  maximum File length (in lines)
#    --max-function-length=<0-999>              maximum Function length (in lines)
#    --max-name-length=<0-999>                  maximum Identifier name length (in characters)
#    --max-severity=<error|warning (default)>   maximum severity
#    --max-struct-length=<0-999>                maximum Struct length (in lines)
#    --min-name-length=<1-999>                  minimum Identifier name length (in characters)
# sonar.swift.tailor.config=--no-color --max-line-length=100 --max-file-length=500 --max-name-length=40 --max-name-length=40 --min-name-length=4
```

## 配置swiftlint相关文件

官方SwiftLint规则说明：`https://realm.github.io/SwiftLint/rule-directory.html`

在要扫描的项目根目录下新建一个名为`.swiftlint.yml`的文件，该文件规定了扫描的具体规则：

```shell
disabled_rules: # 执行时排除掉的规则

# 如果需要自己定义规则，可以使用：custom_rules

# 无关紧要的规则

  - anyobject_protocol # 对纯类协议使用 AnyObject 而不是 class
  - array_init # 序列转化成数组时, 优先使用数组转化, 而不是seq.map{$0} 将序列转换为数组
  - attributes # 函数和类型中，属性应该在一行
  - block_based_kvo # 使用Swift 3.2+时，首选系统的KVO 的API和keypath
  - closing_brace # 小括号中包含大括号的话不能有空格
  - closure_body_length # 闭包的函数体不应该有太多行
  - closure_end_indentation # 闭包的封闭端和开始端有相同的缩进
  - closure_parameter_position # 闭包参数位置，闭包参数应该和大括号左边在同一行
  - closure_spacing # 在闭包的{}中间要有一个空格,如map({ $0 })
  - collection_alignment # 集合中的所有元素应该垂直对齐
  - colon # 冒号规则，冒号应该紧挨左边，右边空一格
  - comma # 逗号规则，逗号应该紧挨左边，右边空一格
  - compiler_protocol_init # 推荐使用自变量初始化变量
  - conditional_returns_on_newline # 条件语句在下一行返回，if true { return }
  - contains_over_first_not_nil # 类似first函数不能判断是否为nil
  - control_statement # 控制语句, for，while，do，catch语句中的条件不能包含在()中
  - discouraged_direct_init # 阻止直接初始化导致的错误类型, 有类方法的,用类方法初始化(不建议直接init初始化)
  - discouraged_object_literal # 优先使用对象初始化方法, 不建议使用代码块初始化
  - empty_enum_arguments # 当枚举与关联类型匹配时，如果不使用它们，参数可以省略
  - empty_parameters # 闭包参数为空时,建议使用() -> Void, 而不是Void -> Void
  - empty_parentheses_with_trailing_closure # 在使用尾随闭包的时候，应该尽量避免使用空的圆括号
  - extension_access_modifier # 在自定义类中,推荐使用extension扩展
  - fatal_error_message # 执行fatalError错误时，建议有一个提示信息，如:fatalError(“Foo”)
  - file_header # 文件头，新建的文件开始的注释应该一样
  - file_length # 文件内容行数
  - first_where # 不建议在使用filter和map函数后直接使用.first
  - for_where # 使用 for where 代替简单的 for { if }
  - function_body_length # 函数体长度，函数体不应该跨越太多行
  - function_parameter_count # 函数参数个数
  - implicit_return # 建议使用隐式返回闭包; 如: foo.map({ $0 + 1 })
  - implicitly_unwrapped_optional # 尽量避免隐式解析可选类型的使用
  - is_disjoint # 初始化集合Set时,推荐使用Set.isDisjoint(), 不建议:Set.intersection
  - joined_default_parameter # joined方法使用默认分隔符时, 建议使用joined()方法, 而不是joined(separator: “”)方法
  - large_tuple # 定义的元组成员个数
  - leading_whitespace # 文件开始不应该有空格或者换行
  - legacy_cggeometry_functions # 当获取某个视图的宽、高、最小X、最大X值等等，swiftlint推荐使用swift的标准语法，尽量不要使用从Objective-C中的遗留版本，尽量语法swift化
  - legacy_constant # 和属性 legacy_cggeometry_functions 一样，结构范围常数尽量分开、明确、具体，不要使用OC的遗留整体常数，推荐CGPoint.zero，不推荐CGPointZero
  - legacy_constructor # swiftlint要求系统自带构造器， 使用swift语法化，不要使用OC版本的构造器
  - legacy_nsgeometry_functions # ns类几何函数，和前面的几个属性一样，使用swift点语法函数，不使用以前的版本
  - let_var_whitespace # let和var语句应该用空白行与其他语句分开
  - line_length # 每行长度限制
  - literal_expression_end_indentation # 字典和数组的开头和结尾要有相同的缩进格式
  - mark # 标记方法或者属性
  - missing_docs
  - multiline_arguments # 调用函数和方法时, 其参数应该在同一行上，或者每行一个
  - multiline_parameters # 声明函数和方法时, 其参数应该在同一行上，或者每行一个
  - multiple_closures_with_trailing_closure # 当函数有多个闭包时, 不建议使用尾随闭包语法
  - nimble_operator # 快捷操作符，和自由匹配函数相比，更喜欢快捷操作符，比如：>=、 ==、 <=、 <等等
  - no_extension_access_modifier # 在extension扩展前面,不建议使用(fileprivate, public)等修饰符
  - no_grouping_extension # 扩展名不应用于对同一源文件中的代码进行分组
  - number_separator # 数字分割线。当在大量的小数中，应该使用下划线来作为千分位分割线
  - object_literal # swiftlint表示比起图片和颜色初始化，更喜欢对象初始化。因为swift初始化可以用表情，图片，颜色等，这不符合项目中的一些习惯用法。与 discouraged_object_literal 互斥， 个人不推荐
  - opening_brace # 在声明的时候，左大括号应该有一个空格，并且在同一行
  - operator_usage_whitespace # 操作符使用规则，操作符两边应该有空格
  - operator_whitespace # 当定义空格操作符的时候，被定义的名字或类型两边应该各有一个单行空格操作符
  - pattern_matching_keywords # 在switch-case语句中, 建议不要将case中的let和var等关键字放到元组内
  - private_action # IBActions修饰的方法,应该都是私有的
  - private_outlet # IBOutlets修饰的属性应该都是私有的
  - private_over_fileprivate # private比fileprivate的私有程度更高
  - private_unit_test # 私有的单元测试，被标记为private的单元测试不会被测试工具XCTest运行，也就是说，被标记为private的单元测试会被静态跳过
  - protocol_property_accessors_order # 在协议中声明属性时，访问者的顺序应该是get set
  - quick_discouraged_call # 在单元测试中,不建议在describe和content比保重直接调用方法和类
  - quick_discouraged_focused_test # 在单元测试中,不建议集中测试,否则可能不能运行成功
  - quick_discouraged_pending_test # 单元测试中阻止未进行的测试单元
  - redundant_discardable_let # 不需要初始化方法返回结果时,建议使用: _ = Person(), 而不是:let _ = Person()
  - redundant_nil_coalescing # 使用可能为为nil的可选值时,建议使用: str ?? “”, ??左右两侧要有一个空格
  - redundant_optional_initialization # 初始化nil变量时,不建议赋值nil
  - redundant_string_enum_value # 在定义字符串枚举的时候, 当字符串枚举值等于枚举名称时，可以不用赋值
  - redundant_void_return # 当函数返回值为Void时,建议不写返回值, 定义常量或者变量的时候可以
  - required_enum_case # 定义的枚举,必须有与其对应的操作实现
  - return_arrow_whitespace # swiftlint推荐返回箭头和返回类型应该被空格分开
  - shorthand_operator # 在swiftlint中，在做一些赋值操作的时候，推荐使用简短操作符
  - single_test_class # 单元测试中,测试文件应该包含一个QuickSpec或XCTestCase类
  - sorted_first_last # 在获取某数组中最大最小值时,建议使用min和max函数,而不是sorted().first和sorted().last
  - sorted_imports # 要求导入的时候导入的类要按顺序导入
  - statement_position # 指的是 else 和 catch 前面要加一个空格，也不能大于1个空格，否则就会触发警告
  - strict_fileprivate # extension中不建议使用fileprivate修饰方法和属性
  - superfluous_disable_command # 被禁用的规则不会在禁用区域触发警告
  - switch_case_alignment # switch-case语句中switch和case应该垂直对齐
  - switch_case_on_newline # 在switch语法里，case应该总是在一个新行上面
  - syntactic_sugar # swiftlint推荐使用速记语法糖，例如 [Int] 代替 Array, 强烈建议推荐使用
  - todo # TODO 和 FIXME 应该避免使用， 使用“notaTODO 和 notaFIXME”代替。另外， 和 MARK 标记不同的是， “notaTODO 和 notaFIXME”没有空格要求
  - trailing_closure # 关于闭包中{}的使用, 推荐使用尾随闭包的语法
  - trailing_comma # 尾部逗号
  - trailing_newline # 文件（属性、方法）结束的的时候（“}”之前），应该有一个空格新行
  - trailing_semicolon # 尽管在变量或常量赋值之后加不加分号在swift中没有硬性的要求，但是为了使code style更swift化，所以尽量或者绝对不要加“;”
  - trailing_whitespace # 函数方法结束后,不建议添加空格行, 和vertical_whitespace貌似有冲突
  - type_body_length # 类型体长度，一般是大括号或者括号内, 比如定义一个enum或struct
  - unneeded_parentheses_in_closure_argument # 在定义或使用闭包时,闭包参数不建议使用括号()
  - unused_closure_parameter # swiftlint建议最好把不使用的闭包参数使用“_”代替
  - unused_enumerated # 在for遍历数组时, 如有未使用的索引,不建议使用.enumerated()
  - unused_optional_binding # 在使用if判断某变量是否为nil的时候, 不建议使用下划线(_)
  - valid_docs
  - valid_ibinspectable # @IBInspectable在swiftlint中的使用需要注意，第一必须是变量，第二必须要有指定的类型，如果指定的类型是可选类型或者隐式类型，则目前官方只支持以下几种类型：String, NSString, UIColor, NSColor, UIImage, NSImage.
  - vertical_parameter_alignment # 当函数参数有多行的时候，函数参数在垂直方向上应该对齐
  - vertical_parameter_alignment_on_call # 当调用多个参数的函数时,如果参数多行显示,则应该垂直对齐
  - vertical_whitespace # 垂直方向上的空格行，限制为一行（注释除外）
  - void_return # 多余的返回值为空，在函数声明的时候，返回值为空是多余的
  - xctfail_message # 单元测试中,XCTFail调用应该包括声明描述
  - yoda_condition

# 还需讨论的规则

  - class_delegate_protocol # 委托协议应该仅是class，可以被弱引用
  - cyclomatic_complexity # 循环复杂度
  - discouraged_optional_boolean # 不建议使用可选布尔值
  - empty_count # 建议使用isEmpty判断,而不是使用count==0判断
  - explicit_acl # 所有属性和方法的声明, 都应该明确指定修饰关键字
  - explicit_type_interface # 声明的属性应该明确其类型, 如: var myVar: Int = 0
  - force_cast # 不建议直接强解类型
  - force_unwrapping # 强制解包
  - generic_type_name # 泛型类型名称只能包含字母数字字符，以大写字母开头，长度介于1到20个字符之间
  - identifier_name # 变量标识符名称应该只包含字母数字字符，并以小写字母开头或只应包含大写字母。在上述例外情况下，当变量名称被声明为静态且不可变时，变量名称可能以大写字母开头。变量名称不应该太长或太短
  - implicit_getter # 对于只有只读属性不建议重写get方法
  - nesting # 嵌套，类型嵌套至多一级结构，函数语句嵌套至多五级结构
  - prefixed_toplevel_constant # 类似全局常量,建议前缀以k开头
  - type_name # 类型名，类型名应该只包含字母数字字符，并且以大写字母开头，长度在3-40个字符
  - variable_name # 变量名规则

opt_in_rules: # 一些规则仅仅是可选的，可以通过执行如下指令来查找所有可用的规则: swiftlint rules

  - discarded_notification_center_observer # 当使用注册的通知时, 应该存储返回的观察者, 便于用完之后移除通知
  - dynamic_inline # 避免一起使用 dynamic 和 @inline(_ _always)，否则报 error
  - fallthrough # switch语句中不建议使用fallthrough
  - for_where # 在for循环中,不建议使用单个if语句或者只使用一次循环变量,可使用where或者if{}else{}语句
  - force_try # 对会抛出异常(throws)的方法,不建议try!强解
  - no_grouping_extension # 只有class和protocol可以使用extension,其他类型不可使用
  - notification_center_detachment # 对象移除通知只能在deinit移除self,函数中不能removeObserver(self)
  - overridden_super_call # 一些重写的方法应该调用super.(父类的)方法
  - override_in_extension # 在extension中,不能重写未声明的属性和未定义的方法
  - prohibited_super_call # 一些方法不应该调用父类的方法
  - unneeded_break_in_switch # 在switch-case语句中, 有方法调用或操作时,避免使用break语句
  - weak_delegate # 代理应该写成weak类型（弱代理）来避免循环引用

excluded: # 执行 linting 时忽略的路径，优先级比 `included` 更高

  - Pods

included: # 执行 linting 时包含的路径

  - Daily-Bill

```

在项目根目录下执行`swiftlint lint > swiftlint.txt`命令，并将生成的`swiftlint.txt`文件移动到自己新建的sonar-reports文件夹下。

如果想要查看SwiftLint Report，在项目根目录下执行命令：`swiftlint lint --reporter html > Daily-Bill.html`，但是生成的html文件请移动至别处，不要放在项目根目录下。

```shell
reporter type (xcode, json, csv, checkstyle, junit, html, emoji, sonarqube, markdown)
```

## 扫描结果

在项目根目录下执行`sonar-scanner`命令，成功后刷新SonarQube网页，即可看到扫描结果，遗憾的是，不知道是由于`sonar-swift`插件的原因还是`SonarQube`的原因，扫描结果都是以`Code Smells`的方式呈现出来。

![](https://raw.githubusercontent.com/Liao-Hexo/image-repository/Description/image-repository/iOS%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0/008vxvgGly1h7ijax7nyvj31jw0ns0vp.jpg)